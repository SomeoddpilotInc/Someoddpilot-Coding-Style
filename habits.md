## Bad Habits

### Ignoring the bigger picture

* Maintaining dead code
* Fixing bugs by overwriting the symptoms of the faulty code
* “Yo Yo” code that converts a value between different representations
* Breaking out high cohesion subroutines that are impossible to reuse in other contexts

### Loose grasp on language

* Using just enough proper syntax needed to break out and writing the rest in a familiar, but improper way.
* Using multiple algorithms to handle different types of operators rather than passing high level functions to generic implementations

### Poor research

* Re-inventing or working without basic mechanisms, classes, and functions of the language or framework

### Distrust of code

* Writing primative boolean functions (`isNull`, `isNotNull`, `isTrue`, `isFalse`)
* Checking boolean variables for anything other than true or false

### Thinking in individual items

* Looping over collections with `for` or `foreach`
* Integrating business-logic with UI or file I/O

### Poor security

* Storing exploitable information in plaintext
* Not performing input validation
* Invoking functions named by user input

### Messy code

* Doesn’t follow a consistent naming convention
* Doesn’t use or uses inconsistent indentation
* Doesn’t properly use whitespace in statements
* Leaves chunks of code commented out

## Good Habits

### Experiment

* Foster a healthy array of side projects
* Dabble in languages and frameworks outside of your usual area
* Try a wacky and bold solution

### Don't get attached

* Don't commit commented out code
* Murder your darlings. Be willing to throw away large amounts of your old code to adopt someone else's more solid solution.
* Don't get fixated on a design pattern that worked successfully once
* Sometimes an off the shelf solution will satisfy your desire to build better than building it yourself
* Maintain someone else's work

### Fix what isn't broken

* Don’t take requirements for a project for granted. Investigate why each aspect is called for and how they relate.
* Use abstraction layers, but don’t lay on too much
* Find ways to reduce the size of the codebase without adding new functionality
* Look to existing functionality to see what can be extended or repurposed before adding

### Ignore heirarchy

* Don’t ask. Do.
* Don’t depend on others to lay or enforce guidelines.

### Think in code

* Code blind

### Live by your language

* Avoid cross-platform solutions
* Sometimes maintaining functionality in two separate codebases *is* sipmler

### Be excited by failure

* Research historic failures to understand their causes and effects
* Take on a small but impossible project

1. [Signs that you’re a good programmer](http://www.yacoset.com/Home/signs-that-you-re-a-good-programmer/)
